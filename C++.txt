C++
__________________________________________________
1. Введение в С++
___________

__________________________________________________
2. Основы языка программирования C++
___________
Структура программы

Инструкции:
	Программа на С++ состоит из набора инструкций.
	Каждая инструкция (statement) выполняет определенное действие.
	В конце инструкции в языке C++ ставится точка с запятой (;). 
	Данный знак указывает компилятору на завершение инструкции.

Блоки кода:
	Набор инструкций может представлять блок кода.
	Блок кода заключается в фигурные скобки
	Инструкции помещаются между открывающей и закрывающей фигурными скобками:
	{
		std::cout << "Hello World!";
		std::cout << "Bye World!"; 
	}

Функция main:
	Каждая программа на языке С++ должна иметь как минимум одну функцию - функцию main().
	Именно с этой функции начинается выполнение приложения.
	Ее имя main фиксировано и для всех программ на С++ всегда одинаково.
	Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми определяется набор инструкций.
	В функции main можно опустить инструкцию return 0;

Директивы препроцессора:
	Каждая директива препроцессора размещается на одной строке.
	Признаком завершения препроцессорной директивы является перевод на новую строку.
	Директива начинается со знака решетки #

Директива "include" определяет, какие файлы и библиотеки надо подключить в данном месте в код программы.

Комментарии:
	При компиляции комментарии игнорируются и не оказывают никакого влияние на работу приложения и на его размер.
	//Однострочный комментарий
	/*Многострочный комментарий*/

Компиляция:
Создание исполняемого файла из исходного кода на C++ в общем случае состоит из трех этапов:
	1.Препроцессор обрабатывает все директивы препроцессора (например, директиву #include).
	2.Компилятор обрабатывает каждый файл с исходным кодом и создает из него объектный файл, который содержит машинный код. 
	3.Компоновщик (линкер/линковщик) объединяет все объектные файлы в единую программу. Данный процесс называется компоновкой/линковкой.
___________
Переменные

Переменная - именнованный участок памяти.

//Определение переменной:
типДанных имяПеременной;

Инициализация переменной:
	Нотация присваивания (assignment notation):
		типДанных имяПеременной;
		имяПеременной = значение;
	Функциональная нотация (functional notation):
		типДанных имяПеременной (значение);
	Инициализация в фигурных скобках (braced initialization):
		типДанных имяПеременной {значение}; //Безопаснее, когда применяется сужающее преобразование

Сужающее преобразование изменяет значение одного типа на тип с более ограниченным диапазоном значений. //Преобразование может привести к потере информации

//Инициализация нулем:
типДанных имяПеременной {}; //Аналогично коду: типДанных имяПеременной {0};

Инициализация по умолчанию:
	Если переменную не инициализировать, то происходит ее инициализация по умолчанию.
	Рекомендуется явно указывать значение, чтобы избегать ошибок при компиляции.

//Изменение значения переменной:
имяПеременной = значение1;
имяПеременной = значение2;
___________
Типы данных

Типы данных:
Логический тип:
	bool: (8 бит) хранит одно из двух значений: true (истинно, верно, 1) и false (неверно, ложно, 0)
Целочисленные типы:
	signed char: (8 бит) от -128 до 127
	unsigned char: (8 бит) от 0 до 255 
	char: (8 бит) представляет один символ в кодировке ASCII. (Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255)
	short: (2 байта) от –32768 до 32767
		псевдонимы: short int, signed short int, signed short.
	unsigned short: (2 байта) от 0 до 65535
		псевдоним: unsigned short int.
	int: В зависимости от архитектуры процессора:
		(2 байта) от –32768 до 32767
		(4 байта) от −2 147 483 648 до 2 147 483 647
		псевдонимы: signed int и signed.
	unsigned int: В зависимости от архитектуры процессора:
		(2 байта) от 0 до 65535
		(4 байта) от 0 до 4 294 967 295
		псевдоним: unsigned
	long: В зависимости от архитектуры процессора:
		(4 байта) от −2 147 483 648 до 2 147 483 647
		(8 байт) от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807
		псевдонимы: long int, signed long int и signed long
	unsigned long: (4 байта) от 0 до 4 294 967 295
		псевдоним: unsigned long int.
	long long: (8 байт) от −9 223 372 036 854 775 808 до +9 223 372 036 854
		псевдонимы: long long int, signed long long int и signed long long.
	unsigned long long: (8 байт) от 0 до 18 446 744 073 709 551 615
		псевдоним: unsigned long long int.
Числа с плавающей точкой:
	float: (4 байта) представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38.
	double: (8 байт) представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308.
	long double: (>=8 байт) представляет вещественное число двойной точности с плавающей точкой.
		В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.
Символьные типы: //Принимает значение в '' или в виде числового кода
	char: (8 бит) представляет один символ в кодировке ASCII. (от -128 до 127, либо от 0 до 255)
	wchar_t: представляет расширенный символ
		На Windows (2 байта) от 0 до 65 535
		на Linux (4 байта) от 0 до 4 294 967 295
	char8_t: (8 бит) от 0 до 256
	char16_t: (2 байта) от 0 до 65 535
	char32_t: (4 байта) от 0 до 4 294 967 295
Спецификатор auto
	Компилятор сам определяет тип данных
	Неинициализированные переменные со спецификатором auto не допускаются

Различные системы исчисления:
	Чтобы указать, что число - шестнадцатеричное, перед числом указывается префикс 0x или 0X
	Чтобы указать, что число - восьмеричное, перед числом указывается ноль 0
	Бинарные литералы предваряются префиксом 0b или 0B
___________
Константы

Константа - именнованный участок памяти, хранящий неизменяемое значение.

//Определение константы:
const типДанных имяКонстанты
___________
Ввод и вывод в консоли

По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль
Средства для ввода с консоли и вывода на консоль предоставляются библиотекой iostream.
В ней определены два типа: 
	istream - представляет поток ввода.
	ostream - представляет поток вывода.

Вывод на консоль
оператор <<
	Левый операнд представляет объект типа ostream (Обычно cout)
	Правый операнд - значение

std::endl / "\n" - Переход на новую строку
"\t" - Табуляция

Ввод на консоль
оператор >>
	Левый операнд представляет объект типа istream (Обычно cin)
	Правый операнд - объект, в который считываются данные
___________
using. Подключение пространств имен и определение псевдонимов

Оператор using - позволяет ввести в программу объекты из различных пространств имен.

Использование оператора using имеет следующий формат:
using пространствоИмен::объект

Определение псевдонимов:
using также позволяет определять псевдонимы для типов:
	Пример: using ullong = unsigned long long;
Старый подход в стиле языка С с помощью оператора typedef:
	Пример: typedef unsigned long long ullong;
___________
Арифметические операции

Арифметические операции:
Бинарные(производятся над двумя операндами):
	+: Операция сложения возвращает сумму двух чисел
	-: Операция вычитания возвращает разность двух чисел
	*: Операция умножения возвращает произведение двух чисел
	/: Операция деления возвращает частное двух чисел
		Если при делении участвует целочисленный операнд, то дробная часть (при ее наличии) будет отбрасываться
	%: Операция получения остатка от целочисленного деления
Унарные(выполняются над одним операндом):
	++(инкремент):
		Префиксный инкремент: Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++i
		Постфиксный инкремент: Увеличивает значение переменной на единицу, но значением выражения i++ будет то, которое было до увеличения на единицу
	--(декремент):
		Префиксный декремент: Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --i
		Постфиксный декремент:Уменьшает значение переменной на единицу, но значением выражения i-- будет то, которое было до уменьшения на единицу

Значение NAN:
NaN(не число) - значение представляет результат операции, который не определяется математически
Результатом любой операции, в которой один или оба операнда являются NaN, также является NaN

Ассоциативность операторов:
Левоассоциативные операторы(большинство операторов) - выполняются слева направо
Правоассоциативные операторы(все унарные операторы, различные операторы присваивания и условный оператор) - выполняются справа налево

Операции в порядке уменьшения приоритета:
++ (инкремент), -- (декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)

Переопределение порядка операций:
Скобки позволяют переопределить порядок вычислений
___________
Статическая типизация и преобразования типов

Статическая типизация - тип каждой переменной определяется на этапе компиляции и не может быть изменен во время выполнения программы

Преобразование типов - переводит данные одного типа в другой
	Неявное преобразование - Компилятор автоматически пребразует типы
	Явное преобразование - преобразование указывается явно
		static_cast<типДанных>(Значение) //Приведение проверяется статически(во время компиляции)
		(типДанных)Значение //Унаследовано от Си

Преобразования в арифметических операциях:
	В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип
	Если операнды имеют разные типы, то:
		Компилятор автоматически выбирает операнд с типом который имеет меньший диапазон значений 
		Компилятор пытается его преобразовать в тип второго операнда с большим диапазоном значений

Безопасные и опасные преобразования:
Безопасные преобразования: преобразования, при которых не происходит потеря информации
Опасные преобразования: преобразования, при которых потенциально может произойти потеря точности данных
___________
Поразрядные операции

Двоичное представление чисел:
На уровне компьютера все данные представлены в виде набора бит(0 и 1)
Число 13 в двоичной системе будет равно 0x1101

Представление отрицательных чисел
Для записи чисел со знаком в С++ применяется дополнительный код (two's complement), при котором старший разряд является знаковым
	Если старший разряд равен 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа
	Если старший разряд равен 1, то число отрицательное

Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу

Операции сдвига:
Операции сдвига применяются только к целочисленным операндам
Операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов (вправо или влево)
	<<: Сдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.
		Один сдвиг влево эквивалентен умножению на 2
	>>: Сдвигает битовое представление числа, представленного первым операндом, вправо на определенное количество разрядов, которое задается вторым операндом.
		Один сдвиг вправо эквивалентен делению на 2

Поразрядные операции:
&: поразрядная конъюнкция (операция И или поразрядное умножение). 
	Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1
|: поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). 
	Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1
^: поразрядное исключающее ИЛИ. 
	Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
~: поразрядное отрицание или инверсия. 
	Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0 и наоборот.
___________
Операции присваивания

=: присваивает значение правого операнда левому операнду
Все операции присваивания имеют правосторонний порядок

Все остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями и имеют общую форму op=:
+=: присваивание после сложения
-=: присваивание после вычитания
*=: присваивание после умножения
/=: присваивание после деления
%=: присваивание после деления по модулю
<<=: присваивание после сдвига разрядов влево
>>=: присваивание после сдвига разрядов вправо
&=: присваивание после поразрядной конъюнкции
|=: присваивание после поразрядной дизъюнкции
^=: присваивание после операции исключающего ИЛИ
___________
Условные выражения

Условные выражения представляют собой некоторое условие и возвращают значение типа bool(true/false)

Операции сравнения:
==: Возвращает true, если оба операнда равны, и false, если они не равны
>: Возвращает true, если первый операнд больше второго. Иначе возвращает false
<: Возвращает true, если первый операнд меньше второго. Иначе возвращает false:
<=: Возвращает true, если первый операнд меньше или равен второму, и false, если первый операнд больше второго:
>=: Возвращает true, если первый операнд больше или равен второму, и false, если первый операнд меньше второго
!=: Возвращает true, если первый операнд не равен второму, и false, если оба операнда равны:

При выводе значения типа bool на консоль, по умолчанию на консоль выводится 1 (если true) и 0 (если false)
Для вывода true/false на консоль, перед выводимым значением указывается манипулятор std::boolalpha

Логические операции:
!: Операция отрицания. Унарная операция, которая возвращает true, если операнд равен false. Если операнд равен true, операция возвращает false.
&&: Конъюнкция, логическое умножение. Возвращает true, если оба операнда не равны false. Возвращает false, если хотя бы один операнд равен false.
||: Дизъюнкция, логическое сложение. Возвращает true, если хотя бы один операнд равен true. Возвращает false, если оба операнда равны false.
^: XOR или eXclusive OR. Возвращает true, если хотя бы оба операнда имеют разные значения. Возвращает false, если оба операнда равны.
___________
Конструкция if-else и тернарный оператор

Условная конструкция if-else направляет ход программы по одному из возможных путей в зависимости от условия
Конструкции if-else могут быть вложенными

if(Условие1) //Части кроме if можно опустить
{
    //Инструкции1
}
else if(Условие2)
{
	//Инструкции2
}
else
{
    //Инструкции3
}

Блок if с инициализацией переменной:
Начиная со стандарта C++17 язык С++ поддерживает особую форму конструкции if:
if(инициализация; условие) //Вне конструкции if-else инициализированные данные не доступны
{
    //Инструкции
}

Тернарный оператор:
операнд1? операнд2 : операнд3
	Первый операнд представляет условие.
	Если условие истинно выполнятся второй операнд
	Если условие ложно выполнятся третий операнд
___________
Конструкция switch-case

Конструкция switch-case позволяет сравнить некоторое выражение с набором значений

switch(выражение)
{
    case значение_1: 
        //Инструкции
        break;
    case значение_2: 
        //Инструкции
        break;
    case значение_N: 
        //Инструкции
        break;
    default: 
        //Инструкции
        break;
}

После выполнения оператора break произойдет выход из конструкции switch..case, и остальные операторы case будут проигнорированы

Можно определять для нескольких меток case один набор инструкций:
case значение_1: 
case значение_2: 
        //Инструкции
        break;

Блок switch с инициализацией переменной:
Начиная со стандарта C++17 язык С++ поддерживает особую форму конструкции switch:
switch(инициализация; условие) //Вне конструкции switch инициализированные данные не доступны
{
    //Блоки case
}
___________
Циклы

Циклы позволяют выполняет некоторый набор инструкций множество раз, пока соблюдается определенное условие.

Цикл c предусловием(while):
while(условие)
{
    //Инструкции
}

Цикл c постусловием(do-while): //Выполнится минимум один раз
do
{
    //Инструкции
}
while(условие);

Цикл for:
for (инициализатор; условие; шаг итерации)
{
    //Инструкции
}
Инициализатор: выполняется один раз при начале выполнения цикла и представляет установку начальных условий.
Условие: представляет условие, при соблюдении которого выполняется цикл.
Итерация: выполняется после каждого завершения блока цикла и задает изменение параметров цикла.

Перебор значений в стиле for-each
Особая форма цикла for: предназначена специально для работы с последовательностями значений
for(типДанных переменная : последовательность)
{
    //Инструкции
}

Операторы continue и break:
continue: производит переход к следующей итерации
break: осуществляет выход из цикла

Бесконечные циклы
for (;;)
while (true)
для выхода из цикла применяется оператор break
___________
Ссылки

Ссылка (reference) представляет способ манипулировать каким-либо объектом.
Является альтернативным именем для объекта.
При инициализации ссылки, она обязательно должна указывать на объект.
Нельзя присвоить ссылке литеральное значение.
Изменения по ссылке неизбежно скажутся и на том объекте, на который ссылается ссылка.
Инициализировать неконстантную ссылку константным объектом нельзя.
Константная ссылка может указывать на обычную переменную, но значение по такой ссылке изменить нельзя.

Определение ссылки: //используется знак '&'
типДанныхОбъекта &имяСсылки = Объект //Обычно ссылка именуется как refОбъект

Особое применение:
Ссылки позволяют манипулировать объектом там, где нельзя манипулироватьим напрямую.
___________
Массивы

Массив - совокупность данных одного типа

Формальное определение массива:
типДанных имяМассива[размерМассива] 

Определение и инициализация массива:
типДанных имяМассива[размерМассива] {значение1, значение2, значение3} //Размер указывать не обязательно

Обращение к элементам массива происходит по индексу
Счет индексов начинается с нуля

Константные массивы определяются с помощью ключевого слова const

Длина массива:
Метод из Си: функция sizeof:
	sizeof(имяМассива) / sizeof(имяМассива[0]) //Общий размер массива / размер одного элемента
Через встроенную библиотечную функцию std::size()
___________
Многомерные массивы

Каждый массив имеет такую характеристику как размерность. 
Количество размерностей соотвествует числу пар квадратных скобок.

Определение двумерного массива:
типДанных имяМассива[размерМассива][размерВложенногоМассива] //Обращение к элементам: имяМассива[i][j]

Перебор вложенного массива с помощью ссылки:
Во внешнем цикле for(auto &имяВложенногоМассива : имяМассива) &имяВложенногоМассива представляет ссылку на подмассив в массиве. 
Во внутреннем цикле for(типДанных имяПеременной : имяВложенногоМассива) 
___________
Массивы символов

Символьные массивы имеют свои особенности.

Инициализация символьных массивов: //Набор символов против строки
char hello1[] {'h', 'e', 'l', 'l', 'o'};
char hello2[] {"hello"};    // {'h', 'e', 'l', 'l', 'o', '\0'}

Способ определения символьного массива влияет на работу с ним:
При выводе на консоль оператор count отобразит всю строку до символа "\0". 
В конце обязательно должен быть символ '\0', иначе на консоль будут выводится символы из последовательных ячеек памяти, которые содержат мусор, пока не:
	Встретится нулевой символ, 
	Произойдет недопустимый доступ к памяти.

Двухмерные массивы символов
Массив строк представляется как двумерный массив символов

Ввод символьных массивов/строк с консоли:
Функция getline() потока cin считывает последовательность символов, включая пробелы
По умолчанию, ввод заканчивается, когда считывается символ перевода строки '\n' 

Функция getline() имеет перегрузку:
	Первая версия принимает два параметра: 
		Первый параметр указывает на массив символов для хранения введенных данных
		Второй параметр указывает на максимальное количество символов, которое надо сохранить в массив.
			Это количество включает символ завершения строки - нулевой байт '\0', который автоматически добавляться в конец ввода.
	Другая форма функции getline() также принимает третий параметр - символ, который будет выступать сигналом завершения ввода (Не будет считан).	
___________
Введение в строки

Стили работы со строками:
	Си-стиль: как с массивом символов (считается опасным из-за нулевого байта '0' в конце)
	Рекомендованный: для хранения строк в C++ используется тип std::string из модуля <string>
		#include <string>
		std::string названиеСтроки;

Получение и изменение символов строки:
	Обращение к символам строки происходит по индексам (как в массиве, индексация с нуля)
	Строка также может использоваться в качестве последовательности(массива)

Чтение строки с консоли 
	При использовании std::cin будет считана строка до пробела
	Для считывания всей строки используется метод getline(std::cin, имяСтроки)
___________
C++
__________________________________________________
1. Введение в С++
___________

__________________________________________________
2. Основы языка программирования C++
___________
Структура программы

Инструкции:
	Программа на С++ состоит из набора инструкций.
	Каждая инструкция (statement) выполняет определенное действие.
	В конце инструкции в языке C++ ставится точка с запятой (;). 
	Данный знак указывает компилятору на завершение инструкции.

Блоки кода:
	Набор инструкций может представлять блок кода.
	Блок кода заключается в фигурные скобки
	Инструкции помещаются между открывающей и закрывающей фигурными скобками:
	{
		std::cout << "Hello World!";
		std::cout << "Bye World!"; 
	}

Функция main:
	Каждая программа на языке С++ должна иметь как минимум одну функцию - функцию main().
	Именно с этой функции начинается выполнение приложения.
	Ее имя main фиксировано и для всех программ на С++ всегда одинаково.
	Функция также является блоком кода, поэтому ее тело обрамляется фигурными скобками, между которыми определяется набор инструкций.
	В функции main можно опустить инструкцию return 0;

Директивы препроцессора:
	Каждая директива препроцессора размещается на одной строке.
	Признаком завершения препроцессорной директивы является перевод на новую строку.
	Директива начинается со знака решетки #

Директива "include" определяет, какие файлы и библиотеки надо подключить в данном месте в код программы.

Комментарии:
	При компиляции комментарии игнорируются и не оказывают никакого влияние на работу приложения и на его размер.
	//Однострочный комментарий
	/*Многострочный комментарий*/

Компиляция:
Создание исполняемого файла из исходного кода на C++ в общем случае состоит из трех этапов:
	1.Препроцессор обрабатывает все директивы препроцессора (например, директиву #include).
	2.Компилятор обрабатывает каждый файл с исходным кодом и создает из него объектный файл, который содержит машинный код. 
	3.Компоновщик (линкер/линковщик) объединяет все объектные файлы в единую программу. Данный процесс называется компоновкой/линковкой.
___________
Переменные

Переменная - именнованный участок памяти.

//Определение переменной:
типДанных имяПеременной;

Инициализация переменной:
	Нотация присваивания (assignment notation):
		типДанных имяПеременной;
		имяПеременной = значение;
	Функциональная нотация (functional notation):
		типДанных имяПеременной (значение);
	Инициализация в фигурных скобках (braced initialization):
		типДанных имяПеременной {значение}; //Безопаснее, когда применяется сужающее преобразование

Сужающее преобразование изменяет значение одного типа на тип с более ограниченным диапазоном значений. //Преобразование может привести к потере информации

//Инициализация нулем:
типДанных имяПеременной {}; //Аналогично коду: типДанных имяПеременной {0};

Инициализация по умолчанию:
	Если переменную не инициализировать, то происходит ее инициализация по умолчанию.
	Рекомендуется явно указывать значение, чтобы избегать ошибок при компиляции.

//Изменение значения переменной:
имяПеременной = значение1;
имяПеременной = значение2;
___________
Типы данных

Типы данных:
Логический тип:
	bool: (8 бит) хранит одно из двух значений: true (истинно, верно, 1) и false (неверно, ложно, 0)
Целочисленные типы:
	signed char: (8 бит) от -128 до 127
	unsigned char: (8 бит) от 0 до 255 
	char: (8 бит) представляет один символ в кодировке ASCII. (Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255)
	short: (2 байта) от –32768 до 32767
		псевдонимы: short int, signed short int, signed short.
	unsigned short: (2 байта) от 0 до 65535
		псевдоним: unsigned short int.
	int: В зависимости от архитектуры процессора:
		(2 байта) от –32768 до 32767
		(4 байта) от −2 147 483 648 до 2 147 483 647
		псевдонимы: signed int и signed.
	unsigned int: В зависимости от архитектуры процессора:
		(2 байта) от 0 до 65535
		(4 байта) от 0 до 4 294 967 295
		псевдоним: unsigned
	long: В зависимости от архитектуры процессора:
		(4 байта) от −2 147 483 648 до 2 147 483 647
		(8 байт) от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807
		псевдонимы: long int, signed long int и signed long
	unsigned long: (4 байта) от 0 до 4 294 967 295
		псевдоним: unsigned long int.
	long long: (8 байт) от −9 223 372 036 854 775 808 до +9 223 372 036 854
		псевдонимы: long long int, signed long long int и signed long long.
	unsigned long long: (8 байт) от 0 до 18 446 744 073 709 551 615
		псевдоним: unsigned long long int.
Числа с плавающей точкой:
	float: (4 байта) представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38.
	double: (8 байт) представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308.
	long double: (>=8 байт) представляет вещественное число двойной точности с плавающей точкой.
		В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.
Символьные типы: //Принимает значение в '' или в виде числового кода
	char: (8 бит) представляет один символ в кодировке ASCII. (от -128 до 127, либо от 0 до 255)
	wchar_t: представляет расширенный символ
		На Windows (2 байта) от 0 до 65 535
		на Linux (4 байта) от 0 до 4 294 967 295
	char8_t: (8 бит) от 0 до 256
	char16_t: (2 байта) от 0 до 65 535
	char32_t: (4 байта) от 0 до 4 294 967 295
Спецификатор auto
	Компилятор сам определяет тип данных
	Неинициализированные переменные со спецификатором auto не допускаются

Различные системы исчисления:
	Чтобы указать, что число - шестнадцатеричное, перед числом указывается префикс 0x или 0X
	Чтобы указать, что число - восьмеричное, перед числом указывается ноль 0
	Бинарные литералы предваряются префиксом 0b или 0B
___________
Константы

Константа - именнованный участок памяти, хранящий неизменяемое значение.

//Определение константы:
const типДанных имяКонстанты
___________
Ввод и вывод в консоли

По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль
Средства для ввода с консоли и вывода на консоль предоставляются библиотекой iostream.
В ней определены два типа: 
	istream - представляет поток ввода.
	ostream - представляет поток вывода.

Вывод на консоль
оператор <<
	Левый операнд представляет объект типа ostream (Обычно cout)
	Правый операнд - значение

std::endl / "\n" - Переход на новую строку
"\t" - Табуляция

Ввод на консоль
оператор >>
	Левый операнд представляет объект типа istream (Обычно cin)
	Правый операнд - объект, в который считываются данные
___________
using. Подключение пространств имен и определение псевдонимов

Оператор using - позволяет ввести в программу объекты из различных пространств имен.

Использование оператора using имеет следующий формат:
using пространствоИмен::объект

Определение псевдонимов:
using также позволяет определять псевдонимы для типов:
	Пример: using ullong = unsigned long long;
Старый подход в стиле языка С с помощью оператора typedef:
	Пример: typedef unsigned long long ullong;
___________
Арифметические операции

Арифметические операции:
Бинарные(производятся над двумя операндами):
	+: Операция сложения возвращает сумму двух чисел
	-: Операция вычитания возвращает разность двух чисел
	*: Операция умножения возвращает произведение двух чисел
	/: Операция деления возвращает частное двух чисел
		Если при делении участвует целочисленный операнд, то дробная часть (при ее наличии) будет отбрасываться
	%: Операция получения остатка от целочисленного деления
Унарные(выполняются над одним операндом):
	++(инкремент):
		Префиксный инкремент: Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++i
		Постфиксный инкремент: Увеличивает значение переменной на единицу, но значением выражения i++ будет то, которое было до увеличения на единицу
	--(декремент):
		Префиксный декремент: Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --i
		Постфиксный декремент:Уменьшает значение переменной на единицу, но значением выражения i-- будет то, которое было до уменьшения на единицу

Значение NAN:
NaN(не число) - значение представляет результат операции, который не определяется математически
Результатом любой операции, в которой один или оба операнда являются NaN, также является NaN

Ассоциативность операторов:
Левоассоциативные операторы(большинство операторов) - выполняются слева направо
Правоассоциативные операторы(все унарные операторы, различные операторы присваивания и условный оператор) - выполняются справа налево

Операции в порядке уменьшения приоритета:
++ (инкремент), -- (декремент)
* (умножение), / (деление), % (остаток от деления)
+ (сложение), - (вычитание)

Переопределение порядка операций:
Скобки позволяют переопределить порядок вычислений
___________
Статическая типизация и преобразования типов

Статическая типизация - тип каждой переменной определяется на этапе компиляции и не может быть изменен во время выполнения программы

Преобразование типов - переводит данные одного типа в другой
	Неявное преобразование - Компилятор автоматически пребразует типы
	Явное преобразование - преобразование указывается явно
		static_cast<типДанных>(Значение) //Приведение проверяется статически(во время компиляции)
		(типДанных)Значение //Унаследовано от Си

Преобразования в арифметических операциях:
	В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип
	Если операнды имеют разные типы, то:
		Компилятор автоматически выбирает операнд с типом который имеет меньший диапазон значений 
		Компилятор пытается его преобразовать в тип второго операнда с большим диапазоном значений

Безопасные и опасные преобразования:
Безопасные преобразования: преобразования, при которых не происходит потеря информации
Опасные преобразования: преобразования, при которых потенциально может произойти потеря точности данных
___________
Поразрядные операции
___________
Операции присваивания
___________
Условные выражения
___________
Конструкция if-else и тернарный оператор
___________
Конструкция switch-case
___________
Циклы
___________
Ссылки
___________
Массивы
___________
Многомерные массивы
___________
Массивы символов
___________
Введение в строки
___________